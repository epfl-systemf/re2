From c6dfc679a6177518b88ddeadb76b1e3b68fb522e Mon Sep 17 00:00:00 2001
From: Erik Giorgis <git@egiorg.is>
Date: Tue, 27 Aug 2024 10:46:22 +0200
Subject: [PATCH] Adding Linear-Time Lookbehinds in RE2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

An extension of the NFA engine to support captureless lookbehinds.
When there are lookbehinds, only the NFA is executed.
Implementing the algorithm from Linear Matching of JavaScript Regular Expressions.

Reviewed-by: Aurèle Barrière <aurele.barriere@epfl.ch>
---
 re2/compile.cc            | 28 +++++++++++++++++++++
 re2/mimics_pcre.cc        |  2 ++
 re2/nfa.cc                | 38 +++++++++++++++++++++++++++-
 re2/onepass.cc            |  5 ++++
 re2/parse.cc              | 52 ++++++++++++++++++++++++++++++++++++++-
 re2/prefilter.cc          |  2 ++
 re2/prog.cc               | 49 ++++++++++++++++++++++++++++++++++++
 re2/prog.h                | 37 ++++++++++++++++++++++------
 re2/re2.cc                | 11 ++++++++-
 re2/regexp.cc             |  6 +++++
 re2/regexp.h              | 12 ++++++++-
 re2/simplify.cc           |  4 +++
 re2/testing/dump.cc       |  4 +++
 re2/testing/parse_test.cc | 15 +++++------
 re2/testing/re2_test.cc   | 20 +++++++++++++++
 re2/tostring.cc           | 11 +++++++++
 16 files changed, 275 insertions(+), 21 deletions(-)

diff --git a/re2/compile.cc b/re2/compile.cc
index 95c1b32..06a7ff4 100644
--- a/re2/compile.cc
+++ b/re2/compile.cc
@@ -133,6 +133,9 @@ class Compiler : public Regexp::Walker<Frag> {
   // Given fragment a, returns (a) capturing as \n.
   Frag Capture(Frag a, int n);
 
+  // Given fragment a, returns (?<=a) if lb>0 or (?<!a) otherwise.
+  Frag LookBehind(Frag a, int lb);
+
   // Given fragments a and b, returns ab; a|b
   Frag Cat(Frag a, Frag b);
   Frag Alt(Frag a, Frag b);
@@ -435,6 +438,26 @@ Frag Compiler::Capture(Frag a, int n) {
   return Frag(id, PatchList::Mk((id+1) << 1), a.nullable);
 }
 
+// Given fragment a, returns a fragment for the lookbehind (?<=a).
+Frag Compiler::LookBehind(Frag a, int lb) {
+
+  int id = AllocInst(2);
+  if (id < 0)
+    return NoMatch();
+  // LBWrite instruction, for the end of the LB automaton.
+  inst_[id].InitLBWrite(lb, 0);
+
+  // The automaton used to check the lookbehind.
+  Frag lb_automaton = Cat(DotStar(), a);
+  // Add the LBWrite instruction at the end.
+  PatchList::Patch(inst_.data(), lb_automaton.end, id);
+
+  // LBCheck instruction, for the main automaton.
+  inst_[id+1].InitLBCheck(lb, lb_automaton.begin, 0);
+
+  return Frag (id+1, PatchList::Mk((id+1) << 1), false);
+}
+
 // A Rune is a name for a Unicode code point.
 // Returns maximum rune encoded by UTF-8 sequence of length len.
 static int MaxRune(int len) {
@@ -953,6 +976,11 @@ Frag Compiler::PostVisit(Regexp* re, Frag, Frag, Frag* child_frags,
       return EndRange();
     }
 
+    case kRegexpPLB:
+      return LookBehind(child_frags[0], re->lb());
+    case kRegexpNLB:
+      return LookBehind(child_frags[0], re->lb());
+
     case kRegexpCapture:
       // If this is a non-capturing parenthesis -- (?:foo) --
       // just use the inner expression.
diff --git a/re2/mimics_pcre.cc b/re2/mimics_pcre.cc
index 1724063..1b587b5 100644
--- a/re2/mimics_pcre.cc
+++ b/re2/mimics_pcre.cc
@@ -163,6 +163,8 @@ bool EmptyStringWalker::PostVisit(Regexp* re, bool parent_arg, bool pre_arg,
     case kRegexpStar:                  // can always be empty
     case kRegexpQuest:
     case kRegexpHaveMatch:
+    case kRegexpPLB:		       // lookbehinds always match empty
+    case kRegexpNLB:
       return true;
 
     case kRegexpConcat:                // can be empty if all children can
diff --git a/re2/nfa.cc b/re2/nfa.cc
index a35976f..3d449a6 100644
--- a/re2/nfa.cc
+++ b/re2/nfa.cc
@@ -51,6 +51,9 @@ class NFA {
   NFA(Prog* prog);
   ~NFA();
 
+  // Stores the last matching index of each lookbehind.
+  std::vector<const char *> lb_table;
+
   // Searches for a matching string.
   //   * If anchored is true, only considers matches starting at offset.
   //     Otherwise finds lefmost match at or after offset.
@@ -133,6 +136,7 @@ class NFA {
 
 NFA::NFA(Prog* prog) {
   prog_ = prog;
+  lb_table = std::vector<const char*>(prog->lb_starts.size());
   start_ = prog_->start();
   ncapture_ = 0;
   longest_ = false;
@@ -144,6 +148,7 @@ NFA::NFA(Prog* prog) {
   // See NFA::AddToThreadq() for why this is so.
   int nstack = 2*prog_->inst_count(kInstCapture) +
                prog_->inst_count(kInstEmptyWidth) +
+               prog_->inst_count(kInstLBCheck) +
                prog_->inst_count(kInstNop) + 1;  // + 1 for start inst
   stack_ = PODArray<AddState>(nstack);
   freelist_ = NULL;
@@ -255,6 +260,27 @@ void NFA::AddToThreadq(Threadq* q, int id0, int c, absl::string_view context,
       a = {id+1, NULL};
       goto Loop;
 
+    case kInstLBWrite:
+      lb_table[std::abs(ip->lb())] = p;
+      break;
+
+    case kInstLBCheck:
+      if (ip->lb() > 0) {
+	// Positive Lookbehind.
+        if (!(lb_table[ip->lb()] == &p[0])) {
+          break; // Lookbehind failed.
+        }
+      } else {
+	//Negative Lookbehind.
+        if (!(lb_table[-ip->lb()] != &p[0])) {
+          break; // Lookbehind failed.
+        }
+      }
+      // Lookbehind succeeded: continue.
+      a = {ip->out(), NULL};
+      goto Loop;
+
+
     case kInstNop:
       if (!ip->last())
         stk[nstk++] = {id+1, NULL};
@@ -575,13 +601,23 @@ bool NFA::Search(absl::string_view text, absl::string_view context,
       // Try to use prefix accel (e.g. memchr) to skip ahead.
       // The search must be unanchored and there must be zero
       // possible matches already.
-      if (!anchored && runq->size() == 0 &&
+      if (!prog_->has_lookbehind() && !anchored && runq->size() == 0 &&
           p < etext_ && prog_->can_prefix_accel()) {
         p = reinterpret_cast<const char*>(prog_->PrefixAccel(p, etext_ - p));
         if (p == NULL)
           p = etext_;
       }
 
+      // Start threads for all lookbehinds positions.
+      for (auto & i : prog_->lb_starts) {
+        Thread* t = AllocThread();
+        CopyCapture(t->capture, match_);
+        t->capture[0] = p;
+        AddToThreadq(runq, i, p < etext_ ? p[0] & 0xFF : -1, context, p,
+                      t);
+        Decref(t);
+      }
+
       Thread* t = AllocThread();
       CopyCapture(t->capture, match_);
       t->capture[0] = p;
diff --git a/re2/onepass.cc b/re2/onepass.cc
index fb7f694..a30d585 100644
--- a/re2/onepass.cc
+++ b/re2/onepass.cc
@@ -447,6 +447,11 @@ bool Prog::IsOnePass() {
           ABSL_LOG(DFATAL) << "unhandled opcode: " << ip->opcode();
           break;
 
+        case kInstLBWrite:
+        case kInstLBCheck:
+          // Not onepass
+          goto fail;
+
         case kInstAltMatch:
           // TODO(rsc): Ignoring kInstAltMatch optimization.
           // Should implement it in this engine, but it's subtle.
diff --git a/re2/parse.cc b/re2/parse.cc
index 6f7a561..466c389 100644
--- a/re2/parse.cc
+++ b/re2/parse.cc
@@ -121,6 +121,11 @@ class Regexp::ParseState {
   bool DoLeftParen(absl::string_view name);
   bool DoLeftParenNoCapture();
 
+  // Processes a lookbehind in the input.
+  // Pushes a marker onto the stack.
+  bool DoPosLookBehind();
+  bool DoNegLookBehind();
+
   // Processes a vertical bar in the input.
   bool DoVerticalBar();
 
@@ -181,6 +186,7 @@ private:
   Regexp* stacktop_;
   int ncap_;  // number of capturing parens seen
   int rune_max_;  // maximum char value for this encoding
+  int nlb_;  // number of lookbehinds seen
 
   ParseState(const ParseState&) = delete;
   ParseState& operator=(const ParseState&) = delete;
@@ -189,12 +195,14 @@ private:
 // Pseudo-operators - only on parse stack.
 const RegexpOp kLeftParen = static_cast<RegexpOp>(kMaxRegexpOp+1);
 const RegexpOp kVerticalBar = static_cast<RegexpOp>(kMaxRegexpOp+2);
+const RegexpOp kPosLookBehind = static_cast<RegexpOp>(kMaxRegexpOp+3);
+const RegexpOp kNegLookBehind = static_cast<RegexpOp>(kMaxRegexpOp+4);
 
 Regexp::ParseState::ParseState(ParseFlags flags,
                                absl::string_view whole_regexp,
                                RegexpStatus* status)
   : flags_(flags), whole_regexp_(whole_regexp),
-    status_(status), stacktop_(NULL), ncap_(0) {
+    status_(status), stacktop_(NULL), ncap_(0), nlb_(0) {
   if (flags_ & Latin1)
     rune_max_ = 0xFF;
   else
@@ -645,6 +653,18 @@ bool Regexp::ParseState::DoLeftParenNoCapture() {
   return PushRegexp(re);
 }
 
+bool Regexp::ParseState::DoPosLookBehind() {
+  Regexp* re = new Regexp(kLeftParen, flags_);
+  re->lb_ = ++nlb_;
+  return PushRegexp(re);
+}
+
+bool Regexp::ParseState::DoNegLookBehind() {
+  Regexp* re = new Regexp(kLeftParen, flags_);
+  re->lb_ = -(++nlb_);
+  return PushRegexp(re);
+}
+
 // Processes a vertical bar in the input.
 bool Regexp::ParseState::DoVerticalBar() {
   MaybeConcatString(-1, NoParseFlags);
@@ -720,6 +740,23 @@ bool Regexp::ParseState::DoRightParen() {
   Regexp* re = r2;
   flags_ = re->parse_flags();
 
+  // Handle lookbehinds.
+  if (re->lb_ != 0) {
+    // Rewrite LeftParen as lookbehind if needed.
+    if (re->lb_ > 0) {
+      re->op_ = kRegexpPLB;
+      re->AllocSub(1);
+      re->sub()[0] = FinishRegexp(r1);
+      re->simple_ = re->ComputeSimple();
+    } else {
+      re->op_ = kRegexpNLB;
+      re->AllocSub(1);
+      re->sub()[0] = FinishRegexp(r1);
+      re->simple_ = re->ComputeSimple();
+    }
+    return PushRegexp(re);
+  }
+
   // Rewrite LeftParen as capture if needed.
   if (re->cap_ > 0) {
     re->op_ = kRegexpCapture;
@@ -2307,6 +2344,19 @@ Regexp* Regexp::Parse(absl::string_view s, ParseFlags global_flags,
       }
 
       case '(':
+        if (t.size() > 4 && t[1] == '?' && t[2] == '<' && (t[3] == '=' || t[3] == '!')) {
+          if (t[3] == '=') {
+            if (!ps.DoPosLookBehind()) {
+              return NULL;
+            }
+          } else {
+            if (!ps.DoNegLookBehind()) {
+              return NULL;
+            }
+          }
+          t.remove_prefix(4);
+          break;
+        }
         // "(?" introduces Perl escape.
         if ((ps.flags() & PerlX) && (t.size() >= 2 && t[1] == '?')) {
           // Flag changes and non-capturing groups.
diff --git a/re2/prefilter.cc b/re2/prefilter.cc
index decc412..1ba1f4f 100644
--- a/re2/prefilter.cc
+++ b/re2/prefilter.cc
@@ -629,6 +629,8 @@ Prefilter::Info* Prefilter::Info::Walker::PostVisit(
       info = CClass(re->cc(), latin1());
       break;
 
+    case kRegexpPLB:
+    case kRegexpNLB:
     case kRegexpCapture:
       // These don't affect the set of matching strings.
       info = child_args[0];
diff --git a/re2/prog.cc b/re2/prog.cc
index 9f1cc00..c714839 100644
--- a/re2/prog.cc
+++ b/re2/prog.cc
@@ -56,6 +56,19 @@ void Prog::Inst::InitCapture(int cap, uint32_t out) {
   cap_ = cap;
 }
 
+void Prog::Inst::InitLBWrite(int lb, uint32_t out) {
+  ABSL_DCHECK_EQ(out_opcode_, 0);
+  set_out_opcode(out, kInstLBWrite);
+  lb_ = lb;
+}
+
+void Prog::Inst::InitLBCheck(int lb, uint32_t lb_automaton, uint32_t out) {
+  ABSL_DCHECK_EQ(out_opcode_, 0);
+  set_out_opcode(out, kInstLBCheck);
+  lb_ = lb;
+  out1_ = lb_automaton;
+}
+
 void Prog::Inst::InitEmptyWidth(EmptyOp empty, uint32_t out) {
   ABSL_DCHECK_EQ(out_opcode_, uint32_t{0});
   set_out_opcode(out, kInstEmptyWidth);
@@ -97,6 +110,12 @@ std::string Prog::Inst::Dump() {
     case kInstCapture:
       return absl::StrFormat("capture %d -> %d", cap_, out());
 
+    case kInstLBWrite:
+      return absl::StrFormat("lbwrite %d", lb_);
+
+    case kInstLBCheck:
+      return absl::StrFormat("lbcheck %d -> %d", lb_, out());
+
     case kInstEmptyWidth:
       return absl::StrFormat("emptywidth %#x -> %d",
                              static_cast<int>(empty_), out());
@@ -118,6 +137,7 @@ Prog::Prog()
     reversed_(false),
     did_flatten_(false),
     did_onepass_(false),
+    has_lookbehind_(false),
     start_(0),
     start_unanchored_(0),
     size_(0),
@@ -214,6 +234,8 @@ static bool IsMatch(Prog* prog, Prog::Inst* ip) {
       case kInstByteRange:
       case kInstFail:
       case kInstEmptyWidth:
+      case kInstLBWrite:
+      case kInstLBCheck:
         return false;
 
       case kInstCapture:
@@ -616,6 +638,9 @@ void Prog::Flatten() {
     if (ip->opcode() != kInstAltMatch)  // handled in EmitList()
       ip->set_out(flatmap[ip->out()]);
     inst_count_[ip->opcode()]++;
+    if (ip->opcode() == kInstLBCheck) {
+      lb_add_start(flatmap[ip->out1()]);
+    }
   }
 
 #if !defined(NDEBUG)
@@ -711,12 +736,26 @@ void Prog::MarkSuccessors(SparseArray<int>* rootmap,
         id = ip->out();
         goto Loop;
 
+      case kInstLBCheck:
+        set_lookbehind();
+        // mark this as a root
+        if (!rootmap->has_index(ip->out()))
+          rootmap->set_new(ip->out(), rootmap->size());
+        // mark the writeLB as a root
+        if (!rootmap->has_index(ip->out1()))
+          rootmap->set_new(ip->out1(), rootmap->size());
+        stk->push_back(ip->out1());
+        id = ip->out();
+
+        goto Loop;
+
       case kInstNop:
         id = ip->out();
         goto Loop;
 
       case kInstMatch:
       case kInstFail:
+      case kInstLBWrite:
         break;
     }
   }
@@ -748,6 +787,7 @@ void Prog::MarkDominator(int root, SparseArray<int>* rootmap,
         ABSL_LOG(DFATAL) << "unhandled opcode: " << ip->opcode();
         break;
 
+      case kInstLBCheck:
       case kInstAltMatch:
       case kInstAlt:
         stk->push_back(ip->out1());
@@ -765,6 +805,7 @@ void Prog::MarkDominator(int root, SparseArray<int>* rootmap,
 
       case kInstMatch:
       case kInstFail:
+      case kInstLBWrite:
         break;
     }
   }
@@ -835,10 +876,18 @@ void Prog::EmitList(int root, SparseArray<int>* rootmap,
         flat->back().set_out(rootmap->get_existing(ip->out()));
         break;
 
+      case kInstLBCheck:
+        flat->emplace_back();
+        memmove(&flat->back(), ip, sizeof *ip);
+        flat->back().set_out(rootmap->get_existing(ip->out()));
+        flat->back().out1_ = rootmap->get_existing(ip->out1());
+        break;
+
       case kInstNop:
         id = ip->out();
         goto Loop;
 
+      case kInstLBWrite:
       case kInstMatch:
       case kInstFail:
         flat->emplace_back();
diff --git a/re2/prog.h b/re2/prog.h
index d0889bd..9897100 100644
--- a/re2/prog.h
+++ b/re2/prog.h
@@ -37,6 +37,8 @@ enum InstOp {
   kInstMatch,        // found a match!
   kInstNop,          // no-op; occasionally unavoidable
   kInstFail,         // never match; occasionally unavoidable
+  kInstLBWrite,      // write to lookbehind buffer
+  kInstLBCheck,      // read from lookbehind buffer
   kNumInst,
 };
 
@@ -60,6 +62,12 @@ class Prog {
   Prog();
   ~Prog();
 
+  std::vector<int> lb_starts;
+  void lb_add_start(int pos) {
+    // add to the beginning of the list.
+    lb_starts.insert(lb_starts.begin(), pos);
+  }
+
   // Single instruction in regexp program.
   class Inst {
    public:
@@ -74,6 +82,8 @@ class Prog {
     void InitAlt(uint32_t out, uint32_t out1);
     void InitByteRange(int lo, int hi, int foldcase, uint32_t out);
     void InitCapture(int cap, uint32_t out);
+    void InitLBWrite(int lb, uint32_t out);
+    void InitLBCheck(int lb, uint32_t out, uint32_t out1);
     void InitEmptyWidth(EmptyOp empty, uint32_t out);
     void InitMatch(int id);
     void InitNop(uint32_t out);
@@ -81,17 +91,21 @@ class Prog {
 
     // Getters
     int id(Prog* p) { return static_cast<int>(this - p->inst_.data()); }
-    InstOp opcode() { return static_cast<InstOp>(out_opcode_ & 7); }
-    int last() { return (out_opcode_ >> 3) & 1; }
-    int out() { return out_opcode_ >> 4; }
+    InstOp opcode() { return static_cast<InstOp>(out_opcode_ & 15); }
+    int last() { return (out_opcode_ >> 4) & 1; }
+    int out() { return out_opcode_ >> 5; }
     int out1() {
-      ABSL_DCHECK(opcode() == kInstAlt || opcode() == kInstAltMatch);
+      ABSL_DCHECK(opcode() == kInstAlt || opcode() == kInstAltMatch || opcode() == kInstLBCheck);
       return out1_;
     }
     int cap() {
       ABSL_DCHECK_EQ(opcode(), kInstCapture);
       return cap_;
     }
+    int lb() {
+      ABSL_DCHECK(opcode() == kInstLBWrite || opcode() == kInstLBCheck);
+      return lb_;
+    }
     int lo() {
       ABSL_DCHECK_EQ(opcode(), kInstByteRange);
       return lo_;
@@ -141,21 +155,25 @@ class Prog {
 
    private:
     void set_opcode(InstOp opcode) {
-      out_opcode_ = (out()<<4) | (last()<<3) | opcode;
+      out_opcode_ = (out()<<5) | (last()<<4) | opcode;
     }
 
     void set_last() {
-      out_opcode_ = (out()<<4) | (1<<3) | opcode();
+      out_opcode_ = (out()<<5) | (1<<4) | opcode();
     }
 
     void set_out(int out) {
-      out_opcode_ = (out<<4) | (last()<<3) | opcode();
+      out_opcode_ = (out<<5) | (last()<<4) | opcode();
+    }
+    void set_out1(int out) {
+      out1_ = (out<<5) | (last()<<4) | opcode();
     }
 
     void set_out_opcode(int out, InstOp opcode) {
-      out_opcode_ = (out<<4) | (last()<<3) | opcode;
+      out_opcode_ = (out<<5) | (last()<<4) | opcode;
     }
 
+    int32_t lb_;           // opcode == kInstLBCheck or kInstLBWrite
     uint32_t out_opcode_;  // 28 bits: out, 1 bit: last, 3 (low) bits: opcode
     union {                // additional instruction arguments:
       uint32_t out1_;      // opcode == kInstAlt
@@ -243,6 +261,8 @@ class Prog {
   int bytemap_range() { return bytemap_range_; }
   const uint8_t* bytemap() { return bytemap_; }
   bool can_prefix_accel() { return prefix_size_ != 0; }
+  bool has_lookbehind() { return has_lookbehind_; }
+  void set_lookbehind() { has_lookbehind_ = true; }
 
   // Accelerates to the first likely occurrence of the prefix.
   // Returns a pointer to the first byte or NULL if not found.
@@ -438,6 +458,7 @@ class Prog {
   bool reversed_;           // whether program runs backward over input
   bool did_flatten_;        // has Flatten been called?
   bool did_onepass_;        // has IsOnePass been called?
+  bool has_lookbehind_;     // regexp contains lookbehinds
 
   int start_;               // entry point for program
   int start_unanchored_;    // unanchored entry point for program
diff --git a/re2/re2.cc b/re2/re2.cc
index ffdb367..92fb618 100644
--- a/re2/re2.cc
+++ b/re2/re2.cc
@@ -727,7 +727,8 @@ bool RE2::Match(absl::string_view text,
       longest_match_ ? Prog::kLongestMatch : Prog::kFirstMatch;
 
   bool can_one_pass = is_one_pass_ && ncap <= Prog::kMaxOnePassCapture;
-  bool can_bit_state = prog_->CanBitState();
+  bool can_bit_state = prog_->CanBitState() && !prog_->has_lookbehind();
+  bool has_lookbehind = prog_->has_lookbehind();
   size_t bit_state_text_max_size = prog_->bit_state_text_max_size();
 
 #ifdef RE2_HAVE_THREAD_LOCAL
@@ -741,6 +742,10 @@ bool RE2::Match(absl::string_view text,
       return false;
 
     case UNANCHORED: {
+      if (has_lookbehind) {
+        skipped_test = true;
+        break;
+      }
       if (prog_->anchor_end()) {
         // This is a very special case: we don't need the forward DFA because
         // we already know where the match must end! Instead, the reverse DFA
@@ -823,6 +828,10 @@ bool RE2::Match(absl::string_view text,
         kind = Prog::kFullMatch;
       anchor = Prog::kAnchored;
 
+      if (has_lookbehind) {
+        skipped_test = true;
+        break;
+      }
       // If only a small amount of text and need submatch
       // information anyway and we're going to use OnePass or BitState
       // to get it, we might as well not even bother with the DFA:
diff --git a/re2/regexp.cc b/re2/regexp.cc
index f7e5ba2..3d4fe33 100644
--- a/re2/regexp.cc
+++ b/re2/regexp.cc
@@ -370,6 +370,8 @@ static bool TopEqual(Regexp* a, Regexp* b) {
     case kRegexpWordBoundary:
     case kRegexpNoWordBoundary:
     case kRegexpBeginText:
+    case kRegexpPLB:
+    case kRegexpNLB:
       return true;
 
     case kRegexpEndText:
@@ -443,6 +445,8 @@ bool Regexp::Equal(Regexp* a, Regexp* b) {
     case kRegexpPlus:
     case kRegexpQuest:
     case kRegexpRepeat:
+    case kRegexpPLB:
+    case kRegexpNLB:
     case kRegexpCapture:
       break;
 
@@ -480,6 +484,8 @@ bool Regexp::Equal(Regexp* a, Regexp* b) {
       case kRegexpQuest:
       case kRegexpRepeat:
       case kRegexpCapture:
+      case kRegexpPLB:
+      case kRegexpNLB:
         a2 = a->sub()[0];
         b2 = b->sub()[0];
         if (!TopEqual(a2, b2))
diff --git a/re2/regexp.h b/re2/regexp.h
index 531b420..7626244 100644
--- a/re2/regexp.h
+++ b/re2/regexp.h
@@ -134,6 +134,11 @@ enum RegexpOp {
   // Optionally, capturing name is name_.
   kRegexpCapture,
 
+  // Positive Lookbehind.
+  kRegexpPLB,
+  // Negative Lookbehind.
+  kRegexpNLB,
+
   // Matches any character.
   kRegexpAnyChar,
 
@@ -354,6 +359,10 @@ class Regexp {
     ABSL_DCHECK_EQ(op_, kRegexpCapture);
     return cap_;
   }
+  int lb() {
+    ABSL_DCHECK(op_ == kRegexpPLB || op_ == kRegexpNLB);
+    return lb_;
+  }
   const std::string* name() {
     ABSL_DCHECK_EQ(op_, kRegexpCapture);
     return name_;
@@ -603,8 +612,9 @@ class Regexp {
       int max_;
       int min_;
     };
-    struct {  // Capture
+    struct {  // Capture or lookbehind
       int cap_;
+      int lb_;
       std::string* name_;
     };
     struct {  // LiteralString
diff --git a/re2/simplify.cc b/re2/simplify.cc
index d0524af..987f4a2 100644
--- a/re2/simplify.cc
+++ b/re2/simplify.cc
@@ -75,6 +75,8 @@ bool Regexp::ComputeSimple() {
         return !ccb_->empty() && !ccb_->full();
       return !cc_->empty() && !cc_->full();
     case kRegexpCapture:
+    case kRegexpPLB:
+    case kRegexpNLB:
       subs = sub();
       return subs[0]->simple();
     case kRegexpStar:
@@ -487,6 +489,8 @@ Regexp* SimplifyWalker::PostVisit(Regexp* re,
       re->simple_ = true;
       return re->Incref();
 
+    case kRegexpNLB:
+    case kRegexpPLB:
     case kRegexpConcat:
     case kRegexpAlternate: {
       // These are simple as long as the subpieces are simple.
diff --git a/re2/testing/dump.cc b/re2/testing/dump.cc
index 382ac20..8b85c37 100644
--- a/re2/testing/dump.cc
+++ b/re2/testing/dump.cc
@@ -41,6 +41,8 @@ static const char* kOpcodeNames[] = {
   "que",
   "rep",
   "cap",
+  "plb",
+  "nlb",
   "dot",
   "byte",
   "bol",
@@ -123,6 +125,8 @@ static void DumpRegexpAppending(Regexp* re, std::string* s) {
       for (int i = 0; i < re->nsub(); i++)
         DumpRegexpAppending(re->sub()[i], s);
       break;
+    case kRegexpPLB:
+    case kRegexpNLB:
     case kRegexpStar:
     case kRegexpPlus:
     case kRegexpQuest:
diff --git a/re2/testing/parse_test.cc b/re2/testing/parse_test.cc
index 53ef24e..fe85e8d 100644
--- a/re2/testing/parse_test.cc
+++ b/re2/testing/parse_test.cc
@@ -178,6 +178,12 @@ static Test tests[] = {
   { "abcde", "str{abcde}" },
   { "[Aa][Bb]cd", "cat{strfold{ab}str{cd}}" },
 
+  // Lookbehinds
+  { "ab(?<=cde)", "cat{str{ab}plb{str{cde}}}" },
+  { "ab(?<!cde)", "cat{str{ab}nlb{str{cde}}}" },
+  { "ab(?<=c(?<=d)e)", "cat{str{ab}plb{cat{lit{c}plb{lit{d}}lit{e}}}}" },
+  { "ab(?<=c(?<!d)e)", "cat{str{ab}plb{cat{lit{c}nlb{lit{d}}lit{e}}}}" },
+
   // Reported bug involving \n leaking in despite use of NeverNL.
   { "[^ ]", "cc{0-0x9 0xb-0x1f 0x21-0x10ffff}", TestZeroFlags },
   { "[^ ]", "cc{0-0x9 0xb-0x1f 0x21-0x10ffff}", Regexp::FoldCase },
@@ -572,15 +578,6 @@ TEST(LookAround, ErrorArgs) {
   EXPECT_EQ(status.code(), kRegexpBadPerlOp);
   EXPECT_EQ(status.error_arg(), "(?!");
 
-  re = Regexp::Parse("(?<=foo).*", Regexp::LikePerl, &status);
-  EXPECT_TRUE(re == NULL);
-  EXPECT_EQ(status.code(), kRegexpBadPerlOp);
-  EXPECT_EQ(status.error_arg(), "(?<=");
-
-  re = Regexp::Parse("(?<!foo).*", Regexp::LikePerl, &status);
-  EXPECT_TRUE(re == NULL);
-  EXPECT_EQ(status.code(), kRegexpBadPerlOp);
-  EXPECT_EQ(status.error_arg(), "(?<!");
 }
 
 }  // namespace re2
diff --git a/re2/testing/re2_test.cc b/re2/testing/re2_test.cc
index 04c040e..88ab833 100644
--- a/re2/testing/re2_test.cc
+++ b/re2/testing/re2_test.cc
@@ -609,6 +609,26 @@ TEST(RE2, FullMatchWithNoArgs) {
   ASSERT_FALSE(RE2::FullMatch("hello!", "h.*o"));   // Must be anchored at end
 }
 
+TEST(RE2, LookBehindTest) {
+  ASSERT_TRUE(RE2::FullMatch("hello there", ".*there(?<=hello.*)"));
+  ASSERT_TRUE(RE2::PartialMatch("hello there", "(?<= )there"));
+
+  // Positive Lookbehind Tests.
+  ASSERT_TRUE(RE2::FullMatch("hello there", ".*there(?<=hello.*)"));
+  ASSERT_TRUE(RE2::PartialMatch("hello there", "(?<= )there"));
+  ASSERT_TRUE(RE2::PartialMatch("12345", "(?<=123)45"));
+  ASSERT_TRUE(RE2::PartialMatch("abc123def", "(?<=abc)123"));
+  ASSERT_TRUE(RE2::PartialMatch("abc123def", "(?<=123)def"));
+  ASSERT_FALSE(RE2::PartialMatch("abc123def", "def(?<=def(?<!f))"));
+  ASSERT_TRUE(RE2::PartialMatch("word1 word2 word3", "word2(?<=word1.*)"));
+
+  // Negative Lookbehind Tests.
+  ASSERT_TRUE(RE2::PartialMatch("abc123def", "(?<!def)123"));
+  ASSERT_FALSE(RE2::PartialMatch("abc123def", "(?<!abc)123"));
+  ASSERT_TRUE(RE2::PartialMatch("hello there", "(?<!goodbye )there"));
+  ASSERT_FALSE(RE2::FullMatch("goodbye", "good(?<!d)bye"));
+}
+
 TEST(RE2, PartialMatch) {
   ASSERT_TRUE(RE2::PartialMatch("x", "x"));
   ASSERT_TRUE(RE2::PartialMatch("hello", "h.*o"));
diff --git a/re2/tostring.cc b/re2/tostring.cc
index 24a530e..a9516ab 100644
--- a/re2/tostring.cc
+++ b/re2/tostring.cc
@@ -111,6 +111,15 @@ int ToStringWalker::PreVisit(Regexp* re, int parent_arg, bool* stop) {
       nprec = PrecParen;
       break;
 
+    case kRegexpPLB:
+      t_->append("(?<=");
+      nprec = PrecParen;
+      break;
+    case kRegexpNLB:
+      t_->append("(?<!");
+      nprec = PrecParen;
+      break;
+
     case kRegexpStar:
     case kRegexpPlus:
     case kRegexpQuest:
@@ -283,6 +292,8 @@ int ToStringWalker::PostVisit(Regexp* re, int parent_arg, int pre_arg,
       break;
     }
 
+    case kRegexpPLB:
+    case kRegexpNLB:
     case kRegexpCapture:
       t_->append(")");
       break;
-- 
2.46.0

